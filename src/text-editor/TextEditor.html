<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      background: transparent;
    }

    html {
      display: flex;
      flex: 1;
      flex-direction: column;
      height: 100%;
      margin: 0;
    }

    body {
      background: transparent;
      display: flex;
      flex: 1;
      flex-direction: column;
      overflow: hidden;
    }

    .container {
      background: transparent;
      overflow: hidden;
      display: flex;
      flex: 1;
      flex-direction: column;
    }

    #content {
      background-color: transparent;
      display: flex;
      flex: 1;
      flex-flow: column;
      padding: 16px;
      outline: none;
      overflow: hidden;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    #content::-webkit-scrollbar {
      display: none;
    }

    #content {
      white-space: pre-wrap; /* css-3 */
      white-space: -moz-pre-wrap; /* Mozilla, since 1999 */
      white-space: -o-pre-wrap; /* Opera 7 */
      word-wrap: break-word; /* Internet Explorer 5.5+ */
    }
  </style>
  <link href='https://unpkg.com/boxicons@2.0.9/css/boxicons.min.css' rel='stylesheet'>
  <title>TextEditor</title>
</head>
<body>


<div class="toolbar">
  <div class="head">
    <input type="text" placeholder="Filename" value="untitled" id="filename">
    <select onchange="fileHandle(this.value); this.selectedIndex=0">
      <option value="" selected="" hidden="" disabled="">File</option>
      <option value="new">New file</option>
      <option value="txt">Save as txt</option>
      <option value="pdf">Save as pdf</option>
    </select>
    <select onchange="formatDoc('formatBlock', this.value); this.selectedIndex=0;">
      <option value="" selected="" hidden="" disabled="">Format</option>
      <option value="h1">Heading 1</option>
      <option value="h2">Heading 2</option>
      <option value="h3">Heading 3</option>
      <option value="h4">Heading 4</option>
      <option value="h5">Heading 5</option>
      <option value="h6">Heading 6</option>
      <option value="p">Paragraph</option>
    </select>
    <select onchange="formatDoc('fontSize', this.value); this.selectedIndex=0;">
      <option value="" selected="" hidden="" disabled="">Font size</option>
      <option value="1">Extra small</option>
      <option value="2">Small</option>
      <option value="3">Regular</option>
      <option value="4">Medium</option>
      <option value="5">Large</option>
      <option value="6">Extra Large</option>
      <option value="7">Big</option>
    </select>
    <div class="color">
      <span>Color</span>
      <input type="color" oninput="formatDoc('foreColor', this.value); this.value='#000000';">
    </div>
    <div class="color">
      <span>Background</span>
      <input type="color" oninput="formatDoc('hiliteColor', this.value); this.value='#000000';">
    </div>
  </div>
  <div class="btn-toolbar">
    <button onclick="formatDoc('undo')"><i class='bx bx-undo'></i></button>
    <button onclick="formatDoc('redo')"><i class='bx bx-redo'></i></button>
    <button onclick="formatDoc('bold')"><i class='bx bx-bold'></i></button>
    <button onclick="formatDoc('underline')"><i class='bx bx-underline'></i></button>
    <button onclick="formatDoc('italic')"><i class='bx bx-italic'></i></button>
    <button onclick="formatDoc('strikeThrough')"><i class='bx bx-strikethrough'></i></button>
    <button onclick="formatDoc('justifyLeft')"><i class='bx bx-align-left'></i></button>
    <button onclick="formatDoc('justifyCenter')"><i class='bx bx-align-middle'></i></button>
    <button onclick="formatDoc('justifyRight')"><i class='bx bx-align-right'></i></button>
    <button onclick="formatDoc('justifyFull')"><i class='bx bx-align-justify'></i></button>
    <button onclick="formatDoc('insertOrderedList')"><i class='bx bx-list-ol'></i></button>
    <button onclick="formatDoc('insertUnorderedList')"><i class='bx bx-list-ul'></i></button>
    <button onclick="addLink()"><i class='bx bx-link'></i></button>
    <button onclick="formatDoc('unlink')"><i class='bx bx-unlink'></i></button>
    <button id="show-code" data-active="false">&lt;/&gt;</button>
  </div>
</div>


<div class="container">
  <div id="content" contenteditable="true" spellcheck="false"></div>
</div>

<script>
  // do not delete this function: formatDoc
  function formatDoc(cmd, value = null) {
    if (value) {
      document.execCommand(cmd, false, value);
    } else {
      document.execCommand(cmd);
    }
  }

  const content = document.getElementById("content");

  content.addEventListener("mouseenter", function() {
    const a = content.querySelectorAll("a");
    a.forEach(item => {
      item.addEventListener("mouseenter", function() {
        content.setAttribute("contenteditable", false);
        item.target = "_blank";
      });
      item.addEventListener("mouseleave", function() {
        content.setAttribute("contenteditable", true);
      });
    });
  });

  function startsWithNumberedListItem(str) {
    const regex = /\s*\d+\.|\s*\d+\)/;
    return regex.test(str);
  }

  function getIncrementedNumber(str) {
    const regex = /^(\d+)([.)])\s/;
    const match = str.match(regex);
    if (match) {
      const number = parseInt(match[1], 10);
      const punctuation = match[2];
      const newNumber = number + 1;
      return `${newNumber}${punctuation} `;
    }
    return str;
  }

  function getIncrementedNumberInString(str) {
    const number = getIncrementedNumber(str);
    const t = str.split(" ");
    const nn = t.slice(1, t.length).join(" ");
    return number + nn;
  }

  function numberingHasContent(str) {
    const splitStr = str.split(" ");
    return splitStr.length > 1 && splitStr[1] !== "";
  }

  function getCaretCharacterOffsetWithin(element) {
    let caretOffset = 0;
    let doc = element.ownerDocument || element.document;
    let win = doc.defaultView || doc.parentWindow;
    let sel;
    if (typeof win.getSelection != "undefined") {
      sel = win.getSelection();
      if (sel.rangeCount > 0) {
        let range = win.getSelection().getRangeAt(0);
        let preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(element);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        caretOffset = preCaretRange.toString().length;
      }
    } else if ((sel = doc.selection) && sel.type != "Control") {
      let textRange = sel.createRange();
      let preCaretTextRange = doc.body.createTextRange();
      preCaretTextRange.moveToElementText(element);
      preCaretTextRange.setEndPoint("EndToEnd", textRange);
      caretOffset = preCaretTextRange.text.length;
    }
    return caretOffset;
  }

  function isEndOfLine(listOfContents, cursorPosition) {
    let count = 0;
    for (const element of listOfContents) {
      count += element.length;
      if (count === cursorPosition) {
        return true;
      } else if (count > cursorPosition) {
        return false;
      }
    }
    return false;
  }

  function setCursorPosition(content, selectedRange, position) {
    for (let i = 0; i < content.childNodes.length; i++) {
      if (position <= content.childNodes[i].textContent.length) {
        if (content.childNodes[i].childNodes.length >= 1) {
          setCursorPosition(content.childNodes[i], selectedRange, position);
        } else {
          selectedRange.setStart(content.childNodes[i], position);
        }
        break;
      }
      if (content.childNodes[i].textContent.length === 0 && position === 1) {
        selectedRange.setStartBefore(content.childNodes[i]);
        break;
      }
      position = position - content.childNodes[i].textContent.length;
    }
  }

  function getNodes(content, numberLineHasContent, number, lastInput) {
    let nodes = [];
    let incrementNextNumber = false;
    for (let i = 0; i < content.childNodes.length; i++) {
      // console.log(content.childNodes[i].textContent);
      // TEXT odavde
      if (content.childNodes[i].nodeType === Node.TEXT_NODE) {
        // console.log("text");
        // if (startsWithNumberedListItem(content.childNodes[i].textContent) && incrementNextNumber) {
        //   console.log("text 1");
        //   nodes.push(getIncrementedNumberInString(content.childNodes[i].textContent));
        // } else {
        // console.log("text 2");

        const div = document.createElement("div");
        div.textContent = content.childNodes[i].textContent;
        nodes.push(div);
        // incrementNextNumber = false;
        // }
        // if (content.childNodes.length === 1) {
        //   console.log("text 3");
        //
        //   // const div = document.createElement("div");
        //   const br = document.createElement("br");
        //   // div.appendChild(br);
        //   // nodes.push(br);
        if (numberLineHasContent && content.childNodes[i].textContent === lastInput) {
          // console.log("text 4");

          const div = document.createElement("div");
          div.textContent = number;
          nodes.push(div);
          // const divbr = document.createElement("div");
          const br = document.createElement("br");
          // divbr.appendChild(br);
          // nodes.push(br);
          // incrementNextNumber = true;
        }
        // } else {
        // console.log("text 5");

        // if (numberLineHasContent && content.childNodes[i].textContent === lastInput) {
        //   console.log("text 6");
        //
        //   // const divbr = document.createElement("div");
        //   const br = document.createElement("br");
        //   // divbr.appendChild(br);
        //   // nodes.push(br);
        //
        //   const div = document.createElement("div");
        //   div.textContent = number;
        //   nodes.push(div);
        //   incrementNextNumber = true;
        // } else if (!numberLineHasContent && content.childNodes[i].textContent === lastInput) {
        //   console.log("text 7");
        //
        //   nodes.pop();
        //   incrementNextNumber = false;
        //   if (content.childNodes[i + 1] === undefined
        //     || content.childNodes[i + 1].tagName !== "BR") {
        //     console.log("text 8");
        //
        //     // const divbr = document.createElement("div");
        //     const br = document.createElement("br");
        //     // divbr.appendChild(br);
        //     // nodes.push(br);
        //   }
        // } else
        //   if (content.childNodes[i].nodeType === Node.TEXT_NODE
        //     && content.childNodes[i + 1]
        //     && content.childNodes[i + 1].tagName === "DIV") {
        //   console.log("text 9");
        //
        //   // const divbr = document.createElement("div");
        //   // const br = document.createElement("br");
        //   // divbr.appendChild(br);
        //   // nodes.push(divbr);
        //   // incrementNextNumber = false;
        // }
        // }
      }

        // ###############################################################
      // DIV odavde

      else if (content.childNodes[i].nodeType === Node.ELEMENT_NODE) {
        if (content.childNodes[i].childNodes.length > 1) {
          nodes = [
            ...nodes,
            ...getNodes(content.childNodes[i], numberLineHasContent, number, lastInput),
          ];
        } else if (!numberLineHasContent && content.childNodes[i].textContent === lastInput) {
          // If numbering does not contain content
          // then delete current line

          const div = document.createElement("div");
          div.appendChild(document.createElement("br"));
          nodes.push(div);
          incrementNextNumber = false;

        } else {
          // If numbering does contain content

          if (content.childNodes[i].textContent.length === 0) {
            const divbr = document.createElement("div");
            const br = document.createElement("br");
            divbr.appendChild(br);
            nodes.push(divbr);
            incrementNextNumber = false;

          } else {
            // then copy current line

            if (startsWithNumberedListItem(content.childNodes[i].textContent)
              && incrementNextNumber) {
              // if current line is numbering and has numbering after
              // then increase numbering and copy content

              const div = document.createElement("div");
              div.textContent = getIncrementedNumberInString(content.childNodes[i].textContent);
              nodes.push(div);
            } else {
              // then copy current line

              const div = document.createElement("div");
              div.textContent = content.childNodes[i].textContent;
              nodes.push(div);
              incrementNextNumber = false;
            }

            if (numberLineHasContent && content.childNodes[i].textContent === lastInput) {
              // double check if current line has content
              // and add new line with incremented number
              const div = document.createElement("div");
              div.textContent = number;
              nodes.push(div);
              incrementNextNumber = true;
            }
          }
        }
      }
    }
    return nodes;
  }

  function getNodesSimple(content) {
    let nodes = [];
    for (let i = 0; i < content.childNodes.length; i++) {
      if (content.childNodes[i].nodeType === Node.TEXT_NODE) {
        nodes.push(content.childNodes[i].textContent);
        if (content.childNodes[i + 1].textContent.length > 0) {
          nodes.push(document.createElement("br"));
        }
      } else if (content.childNodes[i].nodeType === Node.ELEMENT_NODE) {
        if (content.childNodes[i].childNodes.length > 1) {
          nodes = [
            ...nodes,
            ...getNodes(content.childNodes[i]),
          ];
        } else {
          if (content.childNodes[i].textContent.length === 0) {
            nodes.push(document.createElement("br"));
          } else {
            nodes.push(content.childNodes[i].textContent);
            nodes.push(document.createElement("br"));
          }
        }
      }
    }

    return nodes;
  }

  content.addEventListener("keypress", function(event) {
    if (event.key === "Enter") {
      let lastInput = getCurrentLine();
      if (startsWithNumberedListItem(lastInput)) {
        const numberLineHasContent = numberingHasContent(lastInput);
        const cursorPosition = getCaretCharacterOffsetWithin(content);
        let listOfContents = content.innerText.split("\n");
        if (isEndOfLine(listOfContents, cursorPosition)) {
          event.preventDefault();
          let nodes = [];
          let number = "";
          if (numberLineHasContent) {
            number = getIncrementedNumber(lastInput);
          }
          handleNumbering(content, numberLineHasContent, number, lastInput);
          // nodes = getNodes(content, numberLineHasContent, number, lastInput);
          // content.replaceChildren(...nodes);
          if (numberLineHasContent) {
            let selectedText = window.getSelection();
            let selectedRange = document.createRange();
            setCursorPosition(content, selectedRange,
              cursorPosition + (number.length === 0 ? 1 : number.length));
            selectedRange.collapse(true);
            selectedText.removeAllRanges();
            selectedText.addRange(selectedRange);
            content.focus();
          } else {
            let selectedText = window.getSelection();
            let selectedRange = document.createRange();
            setCursorPosition(content, selectedRange,
              cursorPosition - (lastInput.length === 0 ? 1 : lastInput.length) + 1);
            selectedRange.collapse(true);
            selectedText.removeAllRanges();
            selectedText.addRange(selectedRange);
            content.focus();
          }
        }
      }
    }
  });

  function handleNumbering(content, numberLineHasContent, number, lastInput) {
    let incrementNextNumber = false;
    let addBeforeCurrent = false;
    let childNodeLength = content.childNodes.length;
    for (let i = 0; i < childNodeLength; i++) {
      // console.log(content.childNodes[i]);

      if (content.childNodes[i].textContent === lastInput &&
        !numberingHasContent(content.childNodes[i].textContent)) {
        content.childNodes[i].textContent = "";
        content.childNodes[i].appendChild(document.createElement("br"));
        break;
      }

      if (!addBeforeCurrent && incrementNextNumber) {
        content.childNodes[i].textContent = getIncrementedNumberInString(
          content.childNodes[i].textContent);
      }

      if (content.childNodes[i].textContent === lastInput
        && content.childNodes[i + 1] !== undefined) {
        addBeforeCurrent = true;
        incrementNextNumber = startsWithNumberedListItem(content.childNodes[i + 1].textContent);
      } else if (content.childNodes[i].textContent === lastInput
        && content.childNodes[i + 1] === undefined) {
        // const tempDiv = document.createElement("div");
        // div.textContent = content.childNodes[i].textContent;
        // content.childNodes[i] = tempDiv

        const div = document.createElement("div");
        div.textContent = number;
        content.appendChild(div);

        addBeforeCurrent = false;
      } else if (addBeforeCurrent) {
        const div = document.createElement("div");
        div.textContent = number;
        content.insertBefore(div, content.childNodes[i]);
        childNodeLength += 1;
        addBeforeCurrent = false;
      }

      if (content.childNodes[i + 1] !== undefined
        && !startsWithNumberedListItem(content.childNodes[i + 1].textContent)) {
        incrementNextNumber = false;
      }
    }
  }

  content.addEventListener("paste", function(event) {

    event.preventDefault();

    const currentCursorPosition = getCaretCharacterOffsetWithin(content);

    let splitText = (event.originalEvent || event).clipboardData.getData("text/plain").split("\r");
    const splitTextLength = splitText.length - 1;
    const text = splitText.join("");

    document.execCommand("insertText", false, text);

    let nodes = getNodesSimple(content);
    content.replaceChildren(...nodes);

    let selectedText = window.getSelection();
    let selectedRange = document.createRange();
    setCursorPosition(content, selectedRange,
      currentCursorPosition + text.length - splitTextLength);
    selectedRange.collapse(true);
    selectedText.removeAllRanges();
    selectedText.addRange(selectedRange);
    content.focus();
  });

  function getCurrentLine() {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null; // No selection or range available
    }
    const range = selection.getRangeAt(0);
    const startNode = range.startContainer;
    if (startNode.nodeType !== Node.TEXT_NODE) {
      return null; // Cursor is not positioned within text node
    }
    const text = startNode.textContent;
    const startIndex = range.startOffset;
    let lineStartIndex = startIndex;
    let lineEndIndex = startIndex;
    while (lineStartIndex > 0 && text[lineStartIndex - 1] !== "\n") {
      lineStartIndex--;
    }
    while (lineEndIndex < text.length && text[lineEndIndex] !== "\n") {
      lineEndIndex++;
    }
    return text.substring(lineStartIndex, lineEndIndex);
  }

</script>
</body>
</html>

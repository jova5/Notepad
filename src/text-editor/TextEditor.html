<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      background: transparent;
    }

    html {
      display: flex;
      flex: 1;
      flex-direction: column;
      height: 100%;
      margin: 0;
    }

    body {
      background: transparent;
      display: flex;
      flex: 1;
      flex-direction: column;
      overflow: hidden;
    }

    .container {
      background: transparent;
      overflow: hidden;
      display: flex;
      flex: 1;
      flex-direction: column;
    }

    #content {
      background-color: transparent;
      display: flex;
      flex: 1;
      flex-flow: column;
      padding: 16px;
      outline: none;
      overflow: hidden;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    #content::-webkit-scrollbar {
      display: none;
    }

    #content {
      white-space: pre-wrap; /* css-3 */
      white-space: -moz-pre-wrap; /* Mozilla, since 1999 */
      white-space: -o-pre-wrap; /* Opera 7 */
      word-wrap: break-word; /* Internet Explorer 5.5+ */
    }
  </style>
  <link href='https://unpkg.com/boxicons@2.0.9/css/boxicons.min.css' rel='stylesheet'>
  <title>TextEditor</title>
</head>
<body>

<div class="container">
  <div id="content" contenteditable="true" spellcheck="false"></div>
</div>

<script>
  // do not delete this function: formatDoc
  function formatDoc(cmd, value = null) {
    if (value) {
      document.execCommand(cmd, false, value);
    } else {
      document.execCommand(cmd);
    }
  }

  const content = document.getElementById("content");

  content.addEventListener("mouseenter", function() {
    const a = content.querySelectorAll("a");
    a.forEach(item => {
      item.addEventListener("mouseenter", function() {
        content.setAttribute("contenteditable", false);
        item.target = "_blank";
      });
      item.addEventListener("mouseleave", function() {
        content.setAttribute("contenteditable", true);
      });
    });
  });

  function startsWithNumberedListItem(str) {
    const regex = /\s*\d+\.|\s*\d+\)/;
    return regex.test(str);
  }

  function getIncrementedNumber(str) {
    const regex = /^(\d+)([.)])\s/;
    const match = str.match(regex);
    if (match) {
      const number = parseInt(match[1], 10);
      const punctuation = match[2];
      const newNumber = number + 1;
      return `${newNumber}${punctuation} `;
    }
    return str;
  }

  function getIncrementedNumberInString(str) {
    const number = getIncrementedNumber(str);
    const t = str.split(" ");
    const nn = t.slice(1, t.length).join(" ");
    return number + nn;
  }

  function numberingHasContent(str) {
    const splitStr = str.split(" ");
    return splitStr.length > 1 && splitStr[1] !== "";
  }

  function getCaretCharacterOffsetWithin(element) {
    let caretOffset = 0;
    let doc = element.ownerDocument || element.document;
    let win = doc.defaultView || doc.parentWindow;
    let sel;
    if (typeof win.getSelection != "undefined") {
      sel = win.getSelection();
      if (sel.rangeCount > 0) {
        let range = win.getSelection().getRangeAt(0);
        let preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(element);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        caretOffset = preCaretRange.toString().length;
      }
    } else if ((sel = doc.selection) && sel.type != "Control") {
      let textRange = sel.createRange();
      let preCaretTextRange = doc.body.createTextRange();
      preCaretTextRange.moveToElementText(element);
      preCaretTextRange.setEndPoint("EndToEnd", textRange);
      caretOffset = preCaretTextRange.text.length;
    }
    return caretOffset;
  }

  function isEndOfLine(listOfContents, cursorPosition) {
    let count = 0;
    for (const element of listOfContents) {
      count += element.length;
      if (count === cursorPosition) {
        return true;
      } else if (count > cursorPosition) {
        return false;
      }
    }
    return false;
  }

  function setCursorPosition(position) {
    let selectedText = window.getSelection();
    let selectedRange = document.createRange();
    for (let i = 0; i < content.childNodes.length; i++) {
      if (position <= content.childNodes[i].textContent.length) {
        selectedRange.setStart(content.childNodes[i], position);
        break;
      }
      if (content.childNodes[i].textContent.length === 0 && position === 1) {
        selectedRange.setStartAfter(content.childNodes[i]);
        break;
      }
      position = position - content.childNodes[i].textContent.length;
    }
    selectedRange.collapse(true);
    selectedText.removeAllRanges();
    selectedText.addRange(selectedRange);
    content.focus();
  }

  function getNodes(content, numberLineHasContent, number, lastInput) {
    let nodes = [];
    let incrementNextNumber = false;
    for (let i = 0; i < content.childNodes.length; i++) {
      if (content.childNodes[i].nodeType === Node.TEXT_NODE) {
        if (startsWithNumberedListItem(content.childNodes[i].textContent) && incrementNextNumber) {
          nodes.push(getIncrementedNumberInString(content.childNodes[i].textContent));
        } else {
          nodes.push(content.childNodes[i].textContent);
          incrementNextNumber = false;
        }
        if (content.childNodes.length === 1) {
          nodes.push(document.createElement("br"));
          if (numberLineHasContent && content.childNodes[i].textContent === lastInput) {
            nodes.push(number);
            nodes.push(document.createElement("br"));
            incrementNextNumber = true;
          }
        } else {
          if (numberLineHasContent && content.childNodes[i].textContent === lastInput) {
            nodes.push(document.createElement("br"));
            nodes.push(number);
            incrementNextNumber = true;
          } else if (!numberLineHasContent && content.childNodes[i].textContent === lastInput) {
            nodes.pop();
            incrementNextNumber = false;
            if (content.childNodes[i + 1] === undefined
              || content.childNodes[i + 1].tagName !== "BR") {
              nodes.push(document.createElement("br"));
            }
          } else if (content.childNodes[i].nodeType === Node.TEXT_NODE && content.childNodes[i
          + 1].tagName === "DIV") {
            nodes.push(document.createElement("br"));
            incrementNextNumber = false;
          }
        }
      } else if (content.childNodes[i].nodeType === Node.ELEMENT_NODE) {
        if (content.childNodes[i].childNodes.length > 1) {
          nodes = [
            ...nodes,
            ...getNodes(content.childNodes[i], numberLineHasContent, number, lastInput),
          ];
        } else {
          if (content.childNodes[i].textContent.length === 0) {
            nodes.push(document.createElement("br"));
            if (content.childNodes[i + 1] !== undefined && !startsWithNumberedListItem(
              content.childNodes[i + 1].textContent)) {
              incrementNextNumber = false;
            }
          } else {
            nodes.push(content.childNodes[i].textContent);
            nodes.push(document.createElement("br"));
            if (numberLineHasContent && content.childNodes[i].textContent === lastInput) {
              nodes.push(number);
              nodes.push(document.createElement("br"));
              incrementNextNumber = true;
            }
          }
        }
      }
    }
    return nodes;
  }

  function getNodesSimple(content) {
    let nodes = [];
    for (let i = 0; i < content.childNodes.length; i++) {
      if (content.childNodes[i].nodeType === Node.TEXT_NODE) {
        nodes.push(content.childNodes[i].textContent);
        if (content.childNodes[i + 1].textContent.length > 0) {
          nodes.push(document.createElement("br"));
        }
      } else if (content.childNodes[i].nodeType === Node.ELEMENT_NODE) {
        if (content.childNodes[i].childNodes.length > 1) {
          nodes = [
            ...nodes,
            ...getNodes(content.childNodes[i]),
          ];
        } else {
          if (content.childNodes[i].textContent.length === 0) {
            nodes.push(document.createElement("br"));
          } else {
            nodes.push(content.childNodes[i].textContent);
            nodes.push(document.createElement("br"));
          }
        }
      }
    }

    return nodes;
  }

  content.addEventListener("keypress", function(event) {
    if (event.key === "Enter") {
      let lastInput = getCurrentLine();
      if (startsWithNumberedListItem(lastInput)) {
        const numberLineHasContent = numberingHasContent(lastInput);
        const cursorPosition = getCaretCharacterOffsetWithin(content);
        let listOfContents = content.innerText.split("\n");
        if (isEndOfLine(listOfContents, cursorPosition)) {
          event.preventDefault();
          let nodes = [];
          let number = "";
          if (numberLineHasContent) {
            number = getIncrementedNumber(lastInput);
          }
          nodes = getNodes(content, numberLineHasContent, number, lastInput);
          content.replaceChildren(...nodes);
          if (numberLineHasContent) {
            setCursorPosition(cursorPosition + (number.length === 0 ? 1 : number.length));
          } else {
            setCursorPosition(cursorPosition - (lastInput.length === 0 ? 1 : lastInput.length) + 1);
          }
        }
      }
    }
  });

  content.addEventListener("paste", function(event) {

    event.preventDefault();

    const currentCursorPosition = getCaretCharacterOffsetWithin(content)

    let splitText = (event.originalEvent || event).clipboardData.getData("text/plain").split("\r");
    const splitTextLength = splitText.length - 1;
    const text = splitText.join("");

    document.execCommand("insertText", false, text);

    let nodes = getNodesSimple(content);
    content.replaceChildren(...nodes);

    setCursorPosition(currentCursorPosition + text.length - splitTextLength);
  });

  function getCurrentLine() {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null; // No selection or range available
    }
    const range = selection.getRangeAt(0);
    const startNode = range.startContainer;
    if (startNode.nodeType !== Node.TEXT_NODE) {
      return null; // Cursor is not positioned within text node
    }
    const text = startNode.textContent;
    const startIndex = range.startOffset;
    let lineStartIndex = startIndex;
    let lineEndIndex = startIndex;
    while (lineStartIndex > 0 && text[lineStartIndex - 1] !== "\n") {
      lineStartIndex--;
    }
    while (lineEndIndex < text.length && text[lineEndIndex] !== "\n") {
      lineEndIndex++;
    }
    return text.substring(lineStartIndex, lineEndIndex);
  }

</script>
</body>
</html>

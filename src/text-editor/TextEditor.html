<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      margin: 0;
      padding: 0;
      background: transparent;
    }

    html {
      display: flex;
      flex: 1;
      flex-direction: column;
      height: 100%;
      margin: 0;
    }

    body {
      background: transparent;
      display: flex;
      flex: 1;
      flex-direction: column;
      overflow: hidden;
    }

    .container {
      background: transparent;
      overflow: hidden;
      display: flex;
      flex: 1;
      flex-direction: column;
    }

    #content {
      background-color: transparent;
      display: flex;
      flex: 1;
      flex-flow: column;
      padding: 16px;
      outline: none;
      overflow: hidden;
      -ms-overflow-style: none;
      scrollbar-width: none;
      white-space: pre-wrap;
    }

    #content::-webkit-scrollbar {
      display: none;
    }

    /*#content {*/
    /*  white-space: pre-wrap; !* css-3 *!*/
    /*  white-space: -moz-pre-wrap; !* Mozilla, since 1999 *!*/
    /*  white-space: -o-pre-wrap; !* Opera 7 *!*/
    /*  word-wrap: break-word; !* Internet Explorer 5.5+ *!*/
    /*}*/
  </style>
  <link href='https://unpkg.com/boxicons@2.0.9/css/boxicons.min.css' rel='stylesheet'>
  <title>TextEditor</title>
</head>
<body>

<div class="toolbar">
  <div class="btn-toolbar">
    <button onclick="formatDoc('undo')"><i class='bx bx-undo'></i></button>
    <button onclick="formatDoc('redo')"><i class='bx bx-redo'></i></button>
    <button onclick="formatDoc('bold')"><i class='bx bx-bold'></i></button>
    <button onclick="formatDoc('underline')"><i class='bx bx-underline'></i></button>
    <button onclick="formatDoc('italic')"><i class='bx bx-italic'></i></button>
    <button onclick="formatDoc('strikeThrough')"><i class='bx bx-strikethrough'></i></button>
  </div>
</div>


<div class="container">
  <div id="content" contenteditable="true" spellcheck="false">
    <div id="placeholder">Note</div>
  </div>
</div>

<script>
  const content = document.getElementById("content");

  function receiveDataFromReactNative(data) {
    if (data !== null && data !== undefined && data !== "") {
      content.innerHTML = formatContent(data);
      history = [{ cursorPosition: content.innerHTML.length, htmlState: content.innerHTML }];
    }
  }

  function formatContent(data) {
    if (data.startsWith("<div>") && data.endsWith("</div>")) {
      return replaceLinks(data);
    } else {
      const transformedContent = data.replace(/<div>(?!<\/div>)/g, "</div><div>");
      const finalContent = `<div>${transformedContent}`;

      return replaceLinks(finalContent);
    }
  }

  function replaceLinks(text) {
    // Regular expression to match URLs
    const urlRegex = /(https?:\/\/[^\s]+)/g;

    // Split the text into segments separated by <div> and </div>
    const segments = text.split(/(<\/?div>)/);

    // Replace URLs with anchor tags only in segments outside <div> tags
    const replacedSegments = segments.map(segment => {
      if (segment.includes("<div>")) {
        return segment; // Ignore segments containing <div>
      }
      return segment.replace(urlRegex, "<a href=\"$1\">$1</a>");
    });

    // Join the segments back together to form the final text
    return replacedSegments.join("");
  }

  let globalSelection = { startOffset: null, endOffset: null };

  // do not delete this function: formatDoc
  function formatDoc(cmd, value = null) {

    if (cmd === "undo") {
      if (position > 0) {
        position -= 1;
      }
      content.innerHTML = history[position].htmlState;
      window.ReactNativeWebView.postMessage(content.innerHTML);

      let selectedText = window.getSelection();
      let selectedRange = document.createRange();
      setCursorPosition(content, selectedRange, history[position].cursorPosition);
      selectedRange.collapse(true);
      selectedText.removeAllRanges();
      selectedText.addRange(selectedRange);
      content.focus();
    } else if (cmd === "redo") {
      if ((position < 31) && (history.length - 1 > position)) {
        position += 1;
      }
      content.innerHTML = history[position].htmlState;
      window.ReactNativeWebView.postMessage(content.innerHTML);

      let selectedText = window.getSelection();
      let selectedRange = document.createRange();
      setCursorPosition(content, selectedRange, history[position].cursorPosition);
      selectedRange.collapse(true);
      selectedText.removeAllRanges();
      selectedText.addRange(selectedRange);
      content.focus();
    } else if (cmd === "bold"
      || cmd === "underline"
      || cmd === "italic"
      || cmd === "strikeThrough") {

      const offsetStart = window.getSelection().getRangeAt(0).startOffset;

      if (globalSelection.startOffset == null) {
        globalSelection = {
          startOffset: offsetStart,
          endOffset: offsetStart + window.getSelection().getRangeAt(0).toString().length,
        };

      }

      document.execCommand(cmd);

      content.innerHTML = formatContent(content.innerHTML);
      let selectedText = window.getSelection();
      let selectedRange = document.createRange();
      setCursorStartSelection(content, selectedRange, globalSelection.startOffset);
      setCursorEndSelection(content, selectedRange, globalSelection.endOffset);
      selectedText.removeAllRanges();
      selectedText.addRange(selectedRange);
      content.focus();
    }
  }

  content.addEventListener("mousedown", function() {
    globalSelection = { startOffset: null, endOffset: null };
  });

  content.addEventListener("touchstart", function() {
    globalSelection = { startOffset: null, endOffset: null };
  });

  content.addEventListener("mouseenter", function() {
    const a = content.querySelectorAll("a");
    a.forEach(item => {
      item.addEventListener("mouseenter", function() {
        content.setAttribute("contenteditable", false);
        item.target = "_blank";
      });
      item.addEventListener("mouseleave", function() {
        content.setAttribute("contenteditable", true);
      });
    });
  });

  content.addEventListener("focus", function() {
    const placeholder = document.getElementById("placeholder");
    if (placeholder) {
      placeholder.remove();
    }
  });

  content.addEventListener("focusout", function() {
    if (content.innerText === "") {
      const placeholder = document.createElement("div");
      placeholder.id = "placeholder";
      placeholder.textContent = "Note";

      content.appendChild(placeholder);
    }
  });

  let typingTimer;
  const doneTypingInterval = 500; // 10 seconds
  let history = [{ cursorPosition: 0, htmlState: "<div></div>" }];
  let position = 0;

  // Event listener for any input in the contenteditable div
  content.addEventListener("input", function() {

    clearTimeout(typingTimer);
    typingTimer = setTimeout(() => {
      const cursorPosition = getCaretCharacterOffsetWithin(content);
      const htmlState = content.innerHTML;
      populateHistory(htmlState, cursorPosition);

      window.ReactNativeWebView.postMessage(htmlState);
    }, doneTypingInterval);
  });

  function populateHistory(html, cursorPosition) {
    if (history.length === 31) {
      history.shift();
      history.push({ cursorPosition: cursorPosition, htmlState: html });
    } else {
      history.push({ cursorPosition: cursorPosition, htmlState: html });
      position += 1;
    }
  }

  function startsWithNumberedListItem(str) {
    const regex = /\s*\d+\.|\s*\d+\)/;
    return regex.test(str);
  }

  function getIncrementedNumber(str) {
    const regex = /^(\d+)([.)])\s/;
    const match = str.match(regex);
    if (match) {
      const number = parseInt(match[1], 10);
      const punctuation = match[2];
      const newNumber = number + 1;
      return `${newNumber}${punctuation} `;
    }
    return str;
  }

  function getIncrementedNumberInString(str) {
    const number = getIncrementedNumber(str);
    const t = str.split(" ");
    const nn = t.slice(1, t.length).join(" ");
    return number + nn;
  }

  function numberingHasContent(str) {
    const splitStr = str.split(" ");
    return splitStr.length > 1 && splitStr[1] !== "";
  }

  function getCaretCharacterOffsetWithin(element) {
    let caretOffset = 0;
    let doc = element.ownerDocument || element.document;
    let win = doc.defaultView || doc.parentWindow;
    let sel;
    if (typeof win.getSelection != "undefined") {
      sel = win.getSelection();
      if (sel.rangeCount > 0) {
        let range = win.getSelection().getRangeAt(0);
        let preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(element);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        caretOffset = preCaretRange.toString().length;
      }
    } else if ((sel = doc.selection) && sel.type != "Control") {
      let textRange = sel.createRange();
      let preCaretTextRange = doc.body.createTextRange();
      preCaretTextRange.moveToElementText(element);
      preCaretTextRange.setEndPoint("EndToEnd", textRange);
      caretOffset = preCaretTextRange.text.length;
    }
    return caretOffset;
  }

  function isEndOfLine(listOfContents, cursorPosition) {
    let count = 0;
    for (const element of listOfContents) {
      count += element.length;
      if (count === cursorPosition) {
        return true;
      } else if (count > cursorPosition) {
        return false;
      }
    }
    return false;
  }

  function setCursorPosition(content, selectedRange, position) {
    for (let i = 0; i < content.childNodes.length; i++) {
      if (position <= content.childNodes[i].textContent.length) {
        if (content.childNodes[i].childNodes.length >= 1) {
          setCursorPosition(content.childNodes[i], selectedRange, position);
        } else {
          selectedRange.setStart(content.childNodes[i], position);
        }
        break;
      }
      if (content.childNodes[i].textContent.length === 0 && position === 1) {
        selectedRange.setStartBefore(content.childNodes[i]);
        break;
      }
      position = position - content.childNodes[i].textContent.length;
    }
  }

  function setCursorStartSelection(content, selectedRange, position) {
    let tempPosition = position;
    for (let i = 0; i < content.childNodes.length; i++) {
      if (tempPosition <= content.childNodes[i].textContent.length) {

        if (content.childNodes[i].childNodes.length >= 1) {

          setCursorStartSelection(content.childNodes[i], selectedRange, tempPosition);
        } else {

          selectedRange.setStart(content.childNodes[i], tempPosition);
        }
        break;
      }
      // if (content.childNodes[i].textContent.length === 0 && position === 1) {
      //   selectedRange.setStartBefore(content.childNodes[i]);
      //   break;
      // }
      tempPosition = tempPosition - content.childNodes[i].textContent.length;
    }
  }

  function setCursorEndSelection(content, selectedRange, position) {
    let tempPosition = position;
    for (let i = 0; i < content.childNodes.length; i++) {

      if (tempPosition <= content.childNodes[i].textContent.length) {

        if (content.childNodes[i].childNodes.length >= 1) {

          setCursorEndSelection(content.childNodes[i], selectedRange, tempPosition);
        } else {

          selectedRange.setEnd(content.childNodes[i], tempPosition);
        }
        break;
      }
      // if (content.childNodes[i].textContent.length === 0 && position === 1) {
      //   selectedRange.setStartBefore(content.childNodes[i]);
      //   break;
      // }
      tempPosition = tempPosition - content.childNodes[i].textContent.length;
    }
  }

  function setCursorSelection(content, selectedRange, startOffset, endOffset) {
    console.log("sO:" + startOffset);
    console.log("eO:" + endOffset);
    for (let i = 0; i < content.childNodes.length; i++) {
      console.log(content.childNodes[i].textContent.length);

      if (startOffset < content.childNodes[i].textContent.length) {
        if (content.childNodes[i].childNodes.length >= 1) {
          setCursorSelection(content.childNodes[i], selectedRange, startOffset, endOffset);
        }
      }
      // if (startOffset <= content.childNodes[i].textContent.length) {
      //   if (content.childNodes[i].childNodes.length >= 1) {
      //     setCursorSelection(content.childNodes[i], selectedRange, startOffset, endOffset);
      //   } else {
      //     selectedRange.setStart(selectedRange.startContainer, startOffset);
      //     selectedRange.setEnd(selectedRange.endContainer, endOffset);
      //   }
      //   break;
      // }
      // if (content.childNodes[i].textContent.length === 0 && startOffset === 1) {
      //   selectedRange.setStartBefore(content.childNodes[i]);
      //   break;
      // }
      // startOffset = startOffset - content.childNodes[i].textContent.length;
      // endOffset = endOffset - content.childNodes[i].textContent.length;
    }
  }

  content.addEventListener("keypress", function(event) {

    // Nzm da li ce ovo uvijek raditi
    if (content.innerHTML === "\n"
      + "    \n"
      + "  "){
      content.innerHTML = "";
    }
    if (event.key === "Enter") {
      let lastInput = getCurrentLine();
      if (startsWithNumberedListItem(lastInput)) {
        const numberLineHasContent = numberingHasContent(lastInput);
        const cursorPosition = getCaretCharacterOffsetWithin(content);
        let listOfContents = content.innerText.split("\n");
        if (isEndOfLine(listOfContents, cursorPosition)) {
          event.preventDefault();
          let nodes = [];
          let number = "";
          if (numberLineHasContent) {
            number = getIncrementedNumber(lastInput);
          }
          handleNumbering(content, numberLineHasContent, number, lastInput);
          // nodes = getNodes(content, numberLineHasContent, number, lastInput);
          // content.replaceChildren(...nodes);
          if (numberLineHasContent) {
            let selectedText = window.getSelection();
            let selectedRange = document.createRange();
            setCursorPosition(content, selectedRange,
              cursorPosition + (number.length === 0 ? 1 : number.length));
            selectedRange.collapse(true);
            selectedText.removeAllRanges();
            selectedText.addRange(selectedRange);
            content.focus();
          } else {
            let selectedText = window.getSelection();
            let selectedRange = document.createRange();
            setCursorPosition(content, selectedRange,
              cursorPosition - (lastInput.length === 0 ? 1 : lastInput.length) + 1);
            selectedRange.collapse(true);
            selectedText.removeAllRanges();
            selectedText.addRange(selectedRange);
            content.focus();
          }
        }
      }
    }
  });

  function handleNumbering(content, numberLineHasContent, number, lastInput) {
    let incrementNextNumber = false;
    let addBeforeCurrent = false;
    let childNodeLength = content.childNodes.length;
    for (let i = 0; i < childNodeLength; i++) {
      // console.log(content.childNodes[i]);

      if (content.childNodes[i].textContent === lastInput &&
        !numberingHasContent(content.childNodes[i].textContent)) {
        content.childNodes[i].textContent = "";
        content.childNodes[i].appendChild(document.createElement("br"));
        break;
      }

      if (!addBeforeCurrent && incrementNextNumber) {
        content.childNodes[i].textContent = getIncrementedNumberInString(
          content.childNodes[i].textContent);
      }

      if (content.childNodes[i].textContent === lastInput
        && content.childNodes[i + 1] !== undefined) {
        addBeforeCurrent = true;
        incrementNextNumber = startsWithNumberedListItem(content.childNodes[i + 1].textContent);
      } else if (content.childNodes[i].textContent === lastInput
        && content.childNodes[i + 1] === undefined) {
        // const tempDiv = document.createElement("div");
        // div.textContent = content.childNodes[i].textContent;
        // content.childNodes[i] = tempDiv

        const div = document.createElement("div");
        div.textContent = number;
        content.appendChild(div);

        addBeforeCurrent = false;
      } else if (addBeforeCurrent) {
        const div = document.createElement("div");
        div.textContent = number;
        content.insertBefore(div, content.childNodes[i]);
        childNodeLength += 1;
        addBeforeCurrent = false;
      }

      if (content.childNodes[i + 1] !== undefined
        && !startsWithNumberedListItem(content.childNodes[i + 1].textContent)) {
        incrementNextNumber = false;
      }
    }
  }

  function getCurrentLine() {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) {
      return null; // No selection or range available
    }
    const range = selection.getRangeAt(0);
    const startNode = range.startContainer;
    if (startNode.nodeType !== Node.TEXT_NODE) {
      return null; // Cursor is not positioned within text node
    }
    const text = startNode.textContent;
    const startIndex = range.startOffset;
    let lineStartIndex = startIndex;
    let lineEndIndex = startIndex;
    while (lineStartIndex > 0 && text[lineStartIndex - 1] !== "\n") {
      lineStartIndex--;
    }
    while (lineEndIndex < text.length && text[lineEndIndex] !== "\n") {
      lineEndIndex++;
    }
    return text.substring(lineStartIndex, lineEndIndex);
  }

</script>
</body>
</html>
